<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rocket Blaster</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the game */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font */
            background-color: #0d1117; /* Dark space background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
        }
        canvas {
            background-color: #000000; /* Black for space */
            border: 4px solid #4a5568; /* Dark border */
            border-radius: 12px; /* Rounded corners for canvas */
            display: block;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1); /* Subtle shadow */
            max-width: 95vw; /* Increased max-width */
            max-height: 90vh; /* Increased max-height */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .game-info {
            color: #e2e8f0; /* Light text color */
            font-size: 1.25rem;
            font-weight: bold;
            display: flex;
            gap: 40px;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.08);
            display: none; /* Hidden by default */
        }
        .message-box button {
            background-color: #4CAF50; /* Green button */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 20px;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .message-box button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
        .explosion-effect {
            position: absolute;
            background-color: orange;
            border-radius: 50%;
            opacity: 0;
            animation: explode 0.5s forwards;
            z-index: 999;
        }

        @keyframes explode {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer" class="game-container">
        <div class="game-info">
            <span id="score">Score: 0</span>
            <span id="penguinsSaved">Penguins Saved: 0</span>
            <span id="goldenPengus" style="color: yellow;">Golden Penguins: 0</span>
            <span id="bossDefeatedCount">Bosses Defeated: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- Message Box for Game Over/Instructions -->
        <div id="messageBox" class="message-box">
            <h2 id="messageTitle" class="text-2xl font-bold mb-4">Rocket Blaster</h2>
            <p id="messageText" class="text-lg">Use LEFT/RIGHT arrows to move. Collect penguins, avoid rocks! Press SPACE to shoot, SHIFT to dash! Press SPACE to start!</p>
            <button id="restartButton">Start Game</button>
        </div>
    </div>

    <script>
        // Get the canvas and its context
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer');

        // Enable image smoothing for smoother scaling
        ctx.imageSmoothingEnabled = true;
        ctx.mozImageSmoothingEnabled = true; // Firefox
        ctx.webkitImageSmoothingEnabled = true; // Chrome, Safari
        ctx.msImageSmoothingEnabled = true; // IE/Edge

        // Game variables
        let score = 0;
        let penguinsSaved = 0;
        let goldenPengus = 0;
        let bossDefeatedCount = 0;
        let gameOver = false;
        let gameStarted = false;
        let animationFrameId; // To store the requestAnimationFrame ID
        let rockSpawnIntervalId; // To store the setInterval ID for rocks
        let penguinSpawnIntervalId; // To store the setInterval ID for penguins
        let difficulty = 1; // Initial difficulty level
        let glowTime = 0; // For pulsating glow effect

        // Stars variables - Declared early to ensure it's always an array
        let stars = [];
        const numStars = 100;
        const starSpeed = 0.5; // Speed at which stars scroll

        // Rocket Image
        const rocketImage = new Image();
        rocketImage.src = 'https://i.imgur.com/IXOAZ9j.png'; // Updated image source
        let rocketImageLoaded = false;
        rocketImage.onload = () => {
            rocketImageLoaded = true;
            draw(); // Redraw once the image is loaded
        };
        rocketImage.onerror = () => {
            console.error("Failed to load rocket image. Using fallback drawing.");
            // Optionally, you could set a flag here to draw the old rocket if the image fails
        };

        // Blue Penguin Images
        const bluePenguinImageSources = [
            'https://i.imgur.com/o8St4Z1.png',
            'https://i.imgur.com/Eu9r5Uo.png',
            'https://i.imgur.com/QjDQg3M.png',
            'https://i.imgur.com/IYLU3BI.png'
        ];
        let loadedBluePenguinImages = [];
        let bluePenguinImagesLoadedCount = 0;

        // Load all blue penguin images
        bluePenguinImageSources.forEach(src => {
            const img = new Image();
            img.src = src;
            img.onload = () => {
                loadedBluePenguinImages.push(img); // Add to the array only on successful load
                bluePenguinImagesLoadedCount++;
                if (bluePenguinImagesLoadedCount === bluePenguinImageSources.length) {
                    draw(); // Redraw once all images are loaded
                }
            };
            img.onerror = () => {
                console.error(`Failed to load blue penguin image: ${src}`);
            };
        });

        // Golden Penguin Image
        const goldenPenguinImage = new Image();
        goldenPenguinImage.src = 'https://i.imgur.com/eIvTGPd.png'; // Updated golden penguin image source
        let goldenPenguinImageLoaded = false;
        goldenPenguinImage.onload = () => {
            goldenPenguinImageLoaded = true;
            draw(); // Redraw once the image is loaded
        };
        goldenPenguinImage.onerror = () => {
            console.error("Failed to load golden penguin image. Using fallback drawing.");
        };

        // Boss Image
        const bossImage = new Image();
        bossImage.src = 'https://i.imgur.com/0DFsv5z.png'; // New boss image source
        let bossImageLoaded = false;
        bossImage.onload = () => {
            bossImageLoaded = true;
            draw(); // Redraw once the image is loaded
        };
        bossImage.onerror = () => {
            console.error("Failed to load boss image. Using fallback drawing.");
        };

        // Bullet Image
        const bulletImage = new Image();
        bulletImage.src = 'https://i.imgur.com/BywpoAV.png'; // New bullet image source
        let bulletImageLoaded = false;
        bulletImage.onload = () => {
            bulletImageLoaded = true;
            draw(); // Redraw once the image is loaded
        };
        bulletImage.onerror = () => {
            console.error("Failed to load bullet image. Using fallback drawing.");
        };


        // Game elements
        const rocket = {
            x: 0, // Will be set dynamically
            y: 0, // Will be set dynamically
            width: 70, // Adjusted for the new image (50 * 1.3 = 65, rounding up slightly for better fit)
            height: 70, // Adjusted for the new image
            dx: 0,
            speed: 7,
            dashSpeed: 20, // How fast the dash is
            dashDuration: 100, // How long the dash lasts (ms)
            dashCooldown: 1000, // Cooldown for dash (ms)
            lastDashTime: 0,
            isDashing: false,
            color: '#ADD8E6' // Light blue rocket (fallback if image fails)
        };

        let rocks = [];
        let baseRockSpeed = 2; // Reduced from 4 * 0.7 to 2 for slower rocks
        let rockSpawnRate = 800; // Increased from 400 to 800 for less frequent rocks
        const minRockRadius = 18 * 0.7; // 30% smaller
        const maxRockRadius = 35 * 0.7; // 30% smaller

        let penguins = []; // This array now holds penguins (normal and golden)
        let basePenguinSpeed = 3; // Base speed for penguins
        const penguinSpawnRate = 1500; // Penguins spawn every 1.5 seconds
        const normalPenguinRadius = 15 * 1.2; // 20% bigger
        const goldenPenguinRadius = normalPenguinRadius * 1.3; // 30% bigger (was 30% smaller than normal, then 30% bigger)
        const goldenPenguinChance = 0.13; // Increased by 30% from 0.1 (now 13%)

        // Boss related variables
        let boss = {
            x: 0,
            y: 50, // Position near the top
            width: 150, // Adjusted for 1:1 aspect ratio
            height: 150, // Adjusted for 1:1 aspect ratio
            health: 1000,
            maxHealth: 1000,
            dx: 3, // Horizontal movement speed
            direction: 1, // 1 for right, -1 for left
            attackInterval: null, // To store the interval for boss attacks
            attackRate: 500, // Boss attacks every 0.5 second (was 1000ms)
            color: '#8B0000', // Dark red boss (fallback)
            active: false
        };

        // Player bullet properties
        let bullets = [];
        const bulletSpeed = 10;
        const bulletWidth = 20; // Adjusted for new image
        const bulletHeight = 20; // Adjusted for new image
        const bulletColor = '#00FFFF'; // Cyan bullet (fallback)
        let lastBulletTime = 0; // New: To track last bullet fired time
        const bulletCooldown = 250; // New: Cooldown for bullets (ms) - adjusted slightly

        // Boss projectile properties
        let bossProjectiles = [];
        const bossProjectileSpeed = 5;
        const bossProjectileRadius = 7; // Made smaller
        const bossProjectileColor = '#00BFFF'; // Changed to Deep Sky Blue for a blue projectile

        // UI elements
        const scoreDisplay = document.getElementById('score');
        const penguinsSavedDisplay = document.getElementById('penguinsSaved'); // New display element
        const goldenPengusDisplay = document.getElementById('goldenPengus'); // New display element
        const bossDefeatedCountDisplay = document.getElementById('bossDefeatedCount'); // New display element
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('messageTitle');
        const messageText = document.getElementById('messageText');
        const restartButton = document.getElementById('restartButton');

        // Keyboard input
        const keys = {};

        // Tone.js Players for sound effects
        let bulletPlayer;
        let bossProjectilePlayer;
        let explosionPlayer;
        let bluePenguinCollectPlayer; // New player for blue penguin sound
        let goldenPenguinCollectPlayer; // New player for golden penguin sound
        let backgroundMusic; // New: For background music
        let musicSequence; // New: Tone.Sequence for the music

        // Function to initialize Tone.js players and music
        function initAudio() {
            // Set a default master volume for all Tone.js output
            Tone.Master.volume.value = -10; // Sets volume to -10dB

            // Using a simple synth for bullet sound, as external URLs are not allowed for sound files.
            // In a real scenario, you'd load a .wav or .mp3 file here.
            bulletPlayer = new Tone.Synth().toDestination();
            bossProjectilePlayer = new Tone.MembraneSynth().toDestination();
            explosionPlayer = new Tone.NoiseSynth().toDestination();
            bluePenguinCollectPlayer = new Tone.Synth().toDestination(); // Initialize for blue penguin
            goldenPenguinCollectPlayer = new Tone.Synth().toDestination(); // Initialize for golden penguin

            // Basic settings for the sounds (adjust as needed)
            bulletPlayer.oscillator.type = "sine";
            bulletPlayer.envelope.attack = 0.001;
            bulletPlayer.envelope.decay = 0.1;
            bulletPlayer.envelope.sustain = 0.01;
            bulletPlayer.envelope.release = 0.2;

            bossProjectilePlayer.envelope.attack = 0.001;
            bossProjectilePlayer.envelope.decay = 0.3;
            bossProjectilePlayer.envelope.sustain = 0.05;
            bossProjectilePlayer.envelope.release = 0.5;

            explosionPlayer.envelope.attack = 0.001;
            explosionPlayer.envelope.decay = 0.5;
            explosionPlayer.envelope.sustain = 0.01;
            explosionPlayer.envelope.release = 1;

            // Settings for blue penguin collection sound
            bluePenguinCollectPlayer.oscillator.type = "triangle";
            bluePenguinCollectPlayer.envelope.attack = 0.01;
            bluePenguinCollectPlayer.envelope.decay = 0.1;
            bluePenguinCollectPlayer.envelope.sustain = 0.05;
            bluePenguinCollectPlayer.envelope.release = 0.3;

            // Settings for golden penguin collection sound (higher pitch, more distinct)
            goldenPenguinCollectPlayer.oscillator.type = "square";
            goldenPenguinCollectPlayer.envelope.attack = 0.01;
            goldenPenguinCollectPlayer.envelope.decay = 0.15;
            goldenPenguinCollectPlayer.envelope.sustain = 0.08;
            goldenPenguinCollectPlayer.envelope.release = 0.4;

            // New: Background Music Setup
            backgroundMusic = new Tone.Synth({
                oscillator: {
                    type: "square" // Square wave for pixelated/chiptune sound
                },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.2,
                    release: 0.5
                }
            }).toDestination();

            // Simple melody for background music
            const melody = [
                "C4", "E4", "G4", "C5",
                "G4", "E4", "C4", null, // null for a rest
                "F4", "A4", "C5", "F5",
                "C5", "A4", "F4", null
            ];

            musicSequence = new Tone.Sequence((time, note) => {
                if (note) {
                    backgroundMusic.triggerAttackRelease(note, "8n", time); // Play note for an 8th note duration
                }
            }, melody, "4n").start(0); // Play each note for a quarter note, starting immediately
            musicSequence.loop = true; // Loop the music
            musicSequence.playbackRate = 1.2; // Slightly faster tempo
        }

        // Event Listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (!gameStarted && e.code === 'Space') {
                // Start audio context on first user interaction
                if (Tone.context.state !== 'running') {
                    Tone.start().then(() => {
                        console.log("Tone.js audio context started:", Tone.context.state);
                    }).catch(err => {
                        console.error("Failed to start Tone.js audio context:", err);
                    });
                }
                startGame();
            }
            // New: Handle shooting with Spacebar (if not for starting game)
            if (gameStarted && e.code === 'Space' && !gameOver) {
                // Check for bullet cooldown before firing
                const currentTime = Date.now();
                if (currentTime - lastBulletTime > bulletCooldown) {
                    spawnBullet();
                    if (bulletPlayer) bulletPlayer.triggerAttackRelease("C4", "8n"); // Play bullet sound
                    lastBulletTime = currentTime; // Update last bullet time
                }
            }
            // New: Handle dash with Shift key
            if (gameStarted && e.code === 'ShiftLeft' && !gameOver) {
                handleDash();
            }
        });
        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });
        restartButton.addEventListener('click', () => {
            // Start audio context on first user interaction (if not already running)
            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log("Tone.js audio context started:", Tone.context.state);
                }).catch(err => {
                    console.error("Failed to start Tone.js audio context:", err);
                });
            }
            hideMessageBox();
            resetGame();
            startGame();
        });

        // Handle window resize to make canvas responsive
        window.addEventListener('resize', resizeCanvas);

        // --- Canvas Resizing ---
        function resizeCanvas() {
            // Set canvas dimensions based on a larger percentage of the window size
            canvas.width = window.innerWidth * 0.9; // 90% of window width
            canvas.height = window.innerHeight * 0.85; // 85% of window height

            // Ensure minimum and maximum sizes
            canvas.width = Math.max(400, Math.min(canvas.width, 1200)); // Increased max width
            canvas.height = Math.max(300, Math.min(canvas.height, 900)); // Increased max height

            // Adjust rocket position to be centered and near bottom
            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - 100;

            // Adjust boss position
            // Maintain 1:1 aspect ratio for boss, scale based on a percentage of canvas width
            const bossSize = Math.min(canvas.width * 0.2, 150); // Max 150px, or 20% of canvas width
            boss.width = bossSize;
            boss.height = bossSize;
            boss.x = canvas.width / 2 - boss.width / 2;
            
            // Re-initialize stars for new canvas size
            initStars();
            draw(); // Redraw after resize
        }

        // --- Game Initialization and Reset ---

        function initGame() {
            score = 0;
            penguinsSaved = 0; // Reset blue penguins saved
            goldenPengus = 0; // Reset golden penguins collected
            // bossDefeatedCount is NOT reset here as per user request
            gameOver = false;
            gameStarted = false;
            difficulty = 1;

            rocket.x = canvas.width / 2 - rocket.width / 2;
            rocket.y = canvas.height - 100;
            rocket.dx = 0;
            rocket.lastDashTime = 0;
            rocket.isDashing = false;

            rocks = [];
            penguins = [];
            bullets = []; // Clear bullets
            bossProjectiles = []; // Clear boss projectiles
            lastBulletTime = 0; // Reset bullet cooldown

            boss.active = false;
            boss.health = boss.maxHealth;
            // Reset boss size and position based on initial canvas size
            const initialBossSize = Math.min(canvas.width * 0.2, 150);
            boss.width = initialBossSize;
            boss.height = initialBossSize;
            boss.x = canvas.width / 2 - boss.width / 2;
            
            if (boss.attackInterval) {
                clearInterval(boss.attackInterval);
                boss.attackInterval = null;
            }

            // Stop music if it's playing
            if (musicSequence && musicSequence.state === 'started') {
                musicSequence.stop();
            }
            
            initStars();
            updateUI();
            draw();
            showMessageBox("Rocket Blaster", "Use LEFT/RIGHT arrows to move. Collect penguins, avoid rocks! Press SPACE to shoot, SHIFT to dash! Press SPACE to start!", true);
        }

        function resetGame() {
            // Clear any existing intervals or animation frames
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (rockSpawnIntervalId) {
                clearInterval(rockSpawnIntervalId);
            }
            if (penguinSpawnIntervalId) { // Clear penguin spawn interval
                clearInterval(penguinSpawnIntervalId);
            }
            if (boss.attackInterval) { // Clear boss attack interval
                clearInterval(boss.attackInterval);
            }
            // Stop music on reset
            if (musicSequence && musicSequence.state === 'started') {
                musicSequence.stop();
            }
            initGame(); // Reinitialize all game elements (except bossDefeatedCount)
        }

        function startGame() {
            gameStarted = true;
            hideMessageBox();
            gameLoop(); // Start the main game loop
            // Start regular spawners only if boss is not active
            if (!boss.active) {
                rockSpawnIntervalId = setInterval(spawnRock, rockSpawnRate / difficulty);
                penguinSpawnIntervalId = setInterval(spawnPenguin, penguinSpawnRate);
            }
            // Start background music
            if (musicSequence) {
                musicSequence.start();
            }
            console.log("Game started, music sequence state:", musicSequence ? musicSequence.state : "not initialized");
        }

        // --- Drawing Functions ---

        function drawRocket() {
            if (gameOver) return; // Don't draw rocket if game is over

            if (rocketImageLoaded) {
                ctx.drawImage(rocketImage, rocket.x, rocket.y, rocket.width, rocket.height);
            } else {
                // Fallback drawing if image not loaded
                ctx.fillStyle = rocket.color;
                // Main body
                ctx.fillRect(rocket.x, rocket.y, rocket.width, rocket.height);
                // Nose cone
                ctx.beginPath();
                ctx.moveTo(rocket.x, rocket.y);
                ctx.lineTo(rocket.x + rocket.width / 2, rocket.y - rocket.height / 4);
                ctx.lineTo(rocket.x + rocket.width, rocket.y);
                ctx.closePath();
                ctx.fill();
                // Fins
                ctx.fillStyle = '#8B0000'; // Dark red fins
                ctx.fillRect(rocket.x - 10, rocket.y + rocket.height * 0.7, 10, rocket.height * 0.3);
                ctx.fillRect(rocket.x + rocket.width, rocket.y + rocket.height * 0.7, 10, rocket.height * 0.3);
            }
        }

        function drawRock(rock) {
            ctx.fillStyle = '#808080'; // Grey rock
            ctx.beginPath();
            // Simple irregular shape for a rock
            ctx.moveTo(rock.x + rock.radius * Math.cos(0), rock.y + rock.radius * Math.sin(0));
            for (let i = 1; i <= 6; i++) {
                const angle = (Math.PI / 3) * i;
                const variation = (Math.random() - 0.5) * 0.4; // Small random variation
                ctx.lineTo(rock.x + rock.radius * (1 + variation) * Math.cos(angle), rock.y + rock.radius * (1 + variation) * Math.sin(angle));
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#696969'; // Darker grey outline
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function drawPenguin(penguin) {
            const x = penguin.x;
            const y = penguin.y;
            const r = penguin.radius; // Use radius for scaling the penguin

            if (penguin.isGolden) {
                // Draw pulsating glow effect for golden penguin
                const glowStrength = Math.sin(glowTime * 0.005) * 0.5 + 0.5; // Pulsates between 0.5 and 1.0
                const glowRadius = r * 1.5 * glowStrength; // Glow size
                ctx.beginPath();
                ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 215, 0, ${0.4 * glowStrength})`; // Golden color with pulsating alpha
                ctx.fill();
                ctx.closePath();

                // Draw golden penguin using image
                if (goldenPenguinImageLoaded && goldenPenguinImage.complete) {
                    const imgWidth = r * 2; // Scale image width based on radius
                    const imgHeight = r * 2.5; // Scale image height based on radius
                    ctx.drawImage(goldenPenguinImage, x - imgWidth / 2, y - imgHeight / 2, imgWidth, imgHeight);
                } else {
                    // Fallback drawing for golden penguin if image not loaded
                    const bodyColor = '#FFD700'; // Golden
                    const wingColor = '#FFD700'; // Golden

                    // Body (oval)
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(x, y + r * 0.2, r * 0.8, r * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Belly (white oval)
                    ctx.fillStyle = '#FFFFFF'; // White
                    ctx.beginPath();
                    ctx.ellipse(x, y + r * 0.4, r * 0.6, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Head (circle)
                    ctx.fillStyle = bodyColor; // Golden
                    ctx.beginPath();
                    ctx.arc(x, y - r * 0.7, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Eyes (white circles)
                    ctx.fillStyle = '#FFFFFF'; // White
                    ctx.beginPath();
                    ctx.arc(x - r * 0.25, y - r * 0.8, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.arc(x + r * 0.25, y - r * 0.8, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Pupils (black dots)
                    ctx.fillStyle = '#000000'; // Black
                    ctx.beginPath();
                    ctx.arc(x - r * 0.25, y - r * 0.8, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.arc(x + r * 0.25, y - r * 0.8, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Beak (orange triangle)
                    ctx.fillStyle = '#FFA500'; // Orange
                    ctx.beginPath();
                    ctx.moveTo(x, y - r * 0.6);
                    ctx.lineTo(x - r * 0.2, y - r * 0.4);
                    ctx.lineTo(x + r * 0.2, y - r * 0.4);
                    ctx.closePath();
                    ctx.fill();

                    // Feet (orange ovals)
                    ctx.fillStyle = '#FFA500'; // Orange
                    ctx.beginPath();
                    ctx.ellipse(x - r * 0.3, y + r * 1.1, r * 0.3, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.ellipse(x + r * 0.3, y + r * 1.1, r * 0.3, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Wings (ovals)
                    ctx.fillStyle = wingColor; // Golden
                    ctx.beginPath();
                    ctx.ellipse(x - r * 0.9, y + r * 0.2, r * 0.3, r * 0.8, -Math.PI / 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.ellipse(x + r * 0.9, y + r * 0.2, r * 0.3, r * 0.8, Math.PI / 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
            } else {
                // Draw blue penguin using image
                if (loadedBluePenguinImages.length > 0 && penguin.image && penguin.image.complete) {
                    const imgWidth = r * 2; // Scale image width based on radius
                    const imgHeight = r * 2.5; // Scale image height based on radius
                    ctx.drawImage(penguin.image, x - imgWidth / 2, y - imgHeight / 2, imgWidth, imgHeight);
                } else {
                    // Fallback drawing for blue penguin if image not loaded or no image assigned
                    const bodyColor = '#ADD8E6'; // Light Blue
                    const wingColor = '#ADD8E6'; // Light Blue

                    // Body (oval)
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(x, y + r * 0.2, r * 0.8, r * 1.2, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Belly (white oval)
                    ctx.fillStyle = '#FFFFFF'; // White
                    ctx.beginPath();
                    ctx.ellipse(x, y + r * 0.4, r * 0.6, r * 0.8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Head (circle)
                    ctx.fillStyle = bodyColor; // Light Blue
                    ctx.beginPath();
                    ctx.arc(x, y - r * 0.7, r * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Eyes (white circles)
                    ctx.fillStyle = '#FFFFFF'; // White
                    ctx.beginPath();
                    ctx.arc(x - r * 0.25, y - r * 0.8, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.arc(x + r * 0.25, y - r * 0.8, r * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Pupils (black dots)
                    ctx.fillStyle = '#000000'; // Black
                    ctx.beginPath();
                    ctx.arc(x - r * 0.25, y - r * 0.8, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.arc(x + r * 0.25, y - r * 0.8, r * 0.08, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Beak (orange triangle)
                    ctx.fillStyle = '#FFA500'; // Orange
                    ctx.beginPath();
                    ctx.moveTo(x, y - r * 0.6);
                    ctx.lineTo(x - r * 0.2, y - r * 0.4);
                    ctx.lineTo(x + r * 0.2, y - r * 0.4);
                    ctx.closePath();
                    ctx.fill();

                    // Feet (orange ovals)
                    ctx.fillStyle = '#FFA500'; // Orange
                    ctx.beginPath();
                    ctx.ellipse(x - r * 0.3, y + r * 1.1, r * 0.3, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.ellipse(x + r * 0.3, y + r * 1.1, r * 0.3, r * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();

                    // Wings (ovals)
                    ctx.fillStyle = wingColor; // Light Blue
                    ctx.beginPath();
                    ctx.ellipse(x - r * 0.9, y + r * 0.2, r * 0.3, r * 0.8, -Math.PI / 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.ellipse(x + r * 0.9, y + r * 0.2, r * 0.3, r * 0.8, Math.PI / 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }

        function drawBullet(bullet) {
            if (bulletImageLoaded) {
                ctx.drawImage(bulletImage, bullet.x, bullet.y, bullet.width, bullet.height);
            } else {
                // Fallback drawing if image not loaded
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            }
        }

        function drawBoss() {
            if (!boss.active) return;

            if (bossImageLoaded) {
                ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);
            } else {
                // Fallback drawing if image not loaded
                ctx.fillStyle = boss.color;
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
            }

            // Draw health bar
            const healthBarWidth = boss.width * 0.8;
            const healthBarHeight = 10;
            const healthBarX = boss.x + (boss.width - healthBarWidth) / 2;
            const healthBarY = boss.y + boss.height + 10;

            ctx.fillStyle = '#FF0000'; // Red background for health bar
            ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

            ctx.fillStyle = '#00FF00'; // Green health
            const currentHealthWidth = (boss.health / boss.maxHealth) * healthBarWidth;
            ctx.fillRect(healthBarX, healthBarY, currentHealthWidth, healthBarHeight);

            ctx.strokeStyle = '#FFFFFF'; // White border for health bar
            ctx.lineWidth = 1;
            ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
        }

        function drawBossProjectile(projectile) {
            ctx.fillStyle = bossProjectileColor;
            ctx.beginPath();
            ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        }

        function initStars() {
            stars = []; // Clear existing stars
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5, // Small stars
                    alpha: Math.random() * 0.8 + 0.2 // Varying brightness
                });
            }
        }

        function drawStars() {
            ctx.fillStyle = '#FFFFFF'; // White stars
            stars.forEach(star => {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });
            ctx.globalAlpha = 1; // Reset alpha
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
            drawStars(); // Draw stars first
            drawRocket();
            rocks.forEach(drawRock);
            penguins.forEach(drawPenguin);
            bullets.forEach(drawBullet); // Draw player bullets
            drawBoss(); // Draw boss if active
            bossProjectiles.forEach(drawBossProjectile); // Draw boss projectiles
        }

        // --- Game Logic Updates ---

        function update() {
            if (gameOver) return;

            // Update glow time for golden penguins
            glowTime = Date.now(); 

            // Move rocket
            if (keys['ArrowLeft'] && rocket.x > 0) {
                rocket.dx = -rocket.speed;
            } else if (keys['ArrowRight'] && rocket.x + rocket.width < canvas.width) {
                rocket.dx = rocket.speed;
            } else {
                rocket.dx = 0;
            }

            // Apply dash if active
            if (rocket.isDashing) {
                rocket.x += rocket.dx * (rocket.dashSpeed / rocket.speed);
            } else {
                rocket.x += rocket.dx;
            }

            // Keep rocket within bounds
            if (rocket.x < 0) {
                rocket.x = 0;
            }
            if (rocket.x + rocket.width > canvas.width) {
                rocket.x = canvas.width - rocket.width;
            }

            // Update stars
            stars.forEach(star => {
                star.y += starSpeed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });

            // Update rocks
            rocks.forEach(rock => {
                rock.y += rock.speed;
            });
            rocks = rocks.filter(rock => rock.y - rock.radius < canvas.height); // Remove off-screen rocks

            // Update penguins
            penguins.forEach(penguin => {
                penguin.y += penguin.speed;
            });
            penguins = penguins.filter(penguin => penguin.y - penguin.radius < canvas.height); // Remove off-screen penguins

            // Update bullets
            bullets.forEach(bullet => {
                bullet.y -= bullet.speed;
            });
            bullets = bullets.filter(bullet => bullet.y + bullet.height > 0); // Remove off-screen bullets

            // Update boss
            if (boss.active) {
                boss.x += boss.dx * boss.direction;
                if (boss.x + boss.width > canvas.width || boss.x < 0) {
                    boss.direction *= -1; // Reverse direction
                }
            }

            // Update boss projectiles
            bossProjectiles.forEach(projectile => {
                projectile.y += projectile.speed;
            });
            bossProjectiles = bossProjectiles.filter(projectile => projectile.y - projectile.radius < canvas.height); // Remove off-screen projectiles

            checkCollisions();
            updateUI();

            // Increase difficulty based on score and activate boss
            if (score >= 1500 && !boss.active && bossDefeatedCount === 0) { // First boss at 1500 score
                spawnBoss();
            } else if (score >= 3000 && !boss.active && bossDefeatedCount === 1) { // Second boss at 3000 score
                spawnBoss();
            } else if (score >= 6000 && !boss.active && bossDefeatedCount === 2) { // Third boss at 6000 score
                spawnBoss();
            }
            // Add more boss spawn conditions as needed
        }

        // --- Collision Detection ---

        function checkCollisions() {
            // Rocket-Rock collision
            rocks.forEach((rock, rockIndex) => {
                const dist = Math.sqrt(
                    (rocket.x + rocket.width / 2 - rock.x) ** 2 +
                    (rocket.y + rocket.height / 2 - rock.y) ** 2
                );
                if (dist < rocket.width / 2 + rock.radius && !rocket.isDashing) {
                    createExplosionEffect(rocket.x + rocket.width / 2, rocket.y + rocket.height / 2);
                    if (explosionPlayer) explosionPlayer.triggerAttackRelease("8n");
                    endGame();
                }
            });

            // Rocket-Penguin collision
            penguins.forEach((penguin, penguinIndex) => {
                const dist = Math.sqrt(
                    (rocket.x + rocket.width / 2 - penguin.x) ** 2 +
                    (rocket.y + rocket.height / 2 - penguin.y) ** 2
                );
                if (dist < rocket.width / 2 + penguin.radius) {
                    if (penguin.isGolden) {
                        score += 100; // Golden penguins give more points
                        goldenPengus++;
                        if (goldenPenguinCollectPlayer) goldenPenguinCollectPlayer.triggerAttackRelease("E5", "16n"); // Higher pitch for golden
                    } else {
                        score += 25; // Blue penguins now give 25 points
                        penguinsSaved++;
                        if (bluePenguinCollectPlayer) bluePenguinCollectPlayer.triggerAttackRelease("C5", "16n"); // Lower pitch for blue
                    }
                    penguins.splice(penguinIndex, 1); // Remove collected penguin
                }
            });

            // Bullet-Boss collision
            if (boss.active) {
                bullets.forEach((bullet, bulletIndex) => {
                    // Check if bullet intersects with boss bounding box
                    if (bullet.x < boss.x + boss.width &&
                        bullet.x + bullet.width > boss.x &&
                        bullet.y < boss.y + boss.height &&
                        bullet.y + bullet.height > boss.y) {

                        boss.health -= 50; // Damage boss
                        bullets.splice(bulletIndex, 1); // Remove bullet

                        if (boss.health <= 0) {
                            createExplosionEffect(boss.x + boss.width / 2, boss.y + boss.height / 2, 100); // Larger explosion for boss
                            if (explosionPlayer) explosionPlayer.triggerAttackRelease("4n"); // Longer explosion sound
                            boss.active = false;
                            bossDefeatedCount++;
                            score += 500; // Bonus for defeating boss
                            // Clear boss attack interval when defeated
                            if (boss.attackInterval) {
                                clearInterval(boss.attackInterval);
                                boss.attackInterval = null;
                            }
                            // Resume regular spawners
                            rockSpawnIntervalId = setInterval(spawnRock, rockSpawnRate / difficulty);
                            penguinSpawnIntervalId = setInterval(spawnPenguin, penguinSpawnRate);
                            // Increase difficulty after boss
                            difficulty += 0.5;
                        }
                    }
                });
            }

            // Rocket-BossProjectile collision
            bossProjectiles.forEach((projectile, projIndex) => {
                const dist = Math.sqrt(
                    (rocket.x + rocket.width / 2 - projectile.x) ** 2 +
                    (rocket.y + rocket.height / 2 - projectile.y) ** 2
                );
                if (dist < rocket.width / 2 + projectile.radius && !rocket.isDashing) {
                    createExplosionEffect(rocket.x + rocket.width / 2, rocket.y + rocket.height / 2);
                    if (explosionPlayer) explosionPlayer.triggerAttackRelease("8n");
                    endGame();
                }
            });
        }

        // --- Spawning Functions ---

        function spawnBullet() {
            bullets.push({
                x: rocket.x + rocket.width / 2 - bulletWidth / 2,
                y: rocket.y,
                width: bulletWidth,
                height: bulletHeight,
                speed: bulletSpeed,
                color: bulletColor
            });
        }

        function spawnRock() {
            if (boss.active) return; // Don't spawn rocks if boss is active
            const radius = Math.random() * (maxRockRadius - minRockRadius) + minRockRadius;
            rocks.push({
                x: Math.random() * (canvas.width - radius * 2) + radius,
                y: -radius, // Start above canvas
                radius: radius,
                speed: baseRockSpeed * difficulty
            });
        }

        function spawnPenguin() {
            if (boss.active) return; // Don't spawn penguins if boss is active
            const isGolden = Math.random() < goldenPenguinChance;
            const radius = isGolden ? goldenPenguinRadius : normalPenguinRadius;
            const randomImage = loadedBluePenguinImages[Math.floor(Math.random() * loadedBluePenguinImages.length)];

            penguins.push({
                x: Math.random() * (canvas.width - radius * 2) + radius,
                y: -radius, // Start above canvas
                radius: radius,
                speed: basePenguinSpeed,
                isGolden: isGolden,
                image: randomImage // Assign a random blue penguin image
            });
        }

        function spawnBoss() {
            boss.active = true;
            boss.health = boss.maxHealth; // Reset boss health
            // Clear regular spawners when boss appears
            if (rockSpawnIntervalId) {
                clearInterval(rockSpawnIntervalId);
                rockSpawnIntervalId = null;
            }
            if (penguinSpawnIntervalId) {
                clearInterval(penguinSpawnIntervalId);
                penguinSpawnIntervalId = null;
            }
            // Start boss attack interval
            boss.attackInterval = setInterval(spawnBossProjectile, boss.attackRate);
        }

        function spawnBossProjectile() {
            if (!boss.active) return;
            bossProjectiles.push({
                x: boss.x + boss.width / 2,
                y: boss.y + boss.height,
                radius: bossProjectileRadius,
                speed: bossProjectileSpeed
            });
            if (bossProjectilePlayer) bossProjectilePlayer.triggerAttackRelease("C2", "16n"); // Play boss projectile sound
        }

        // --- Player Actions ---

        function handleDash() {
            const currentTime = Date.now();
            if (currentTime - rocket.lastDashTime > rocket.dashCooldown && !rocket.isDashing) {
                rocket.isDashing = true;
                rocket.lastDashTime = currentTime;
                setTimeout(() => {
                    rocket.isDashing = false;
                }, rocket.dashDuration);
            }
        }

        // --- UI and Game State Management ---

        function updateUI() {
            scoreDisplay.textContent = `Score: ${score}`;
            penguinsSavedDisplay.textContent = `Penguins Saved: ${penguinsSaved}`;
            goldenPengusDisplay.textContent = `Golden Penguins: ${goldenPengus}`;
            bossDefeatedCountDisplay.textContent = `Bosses Defeated: ${bossDefeatedCount}`;
        }

        function showMessageBox(title, text, showButton = false) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            restartButton.style.display = showButton ? 'block' : 'none';
            messageBox.style.display = 'block';
        }

        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        function createExplosionEffect(x, y, size = 50) {
            const explosion = document.createElement('div');
            explosion.className = 'explosion-effect';
            explosion.style.left = `${x}px`;
            explosion.style.top = `${y}px`;
            explosion.style.width = `${size}px`;
            explosion.style.height = `${size}px`;
            gameContainer.appendChild(explosion);

            // Remove the element after the animation
            explosion.addEventListener('animationend', () => {
                explosion.remove();
            });
        }

        function endGame() {
            gameOver = true;
            gameStarted = false;
            cancelAnimationFrame(animationFrameId);
            clearInterval(rockSpawnIntervalId);
            clearInterval(penguinSpawnIntervalId);
            if (boss.attackInterval) {
                clearInterval(boss.attackInterval);
                boss.attackInterval = null;
            }
            // Stop music on game over
            if (musicSequence && musicSequence.state === 'started') {
                musicSequence.stop();
            }
            showMessageBox("Game Over!", `You scored ${score} points and saved ${penguinsSaved} penguins! You defeated ${bossDefeatedCount} bosses!`, true);
        }

        // --- Main Game Loop ---
        function gameLoop() {
            if (!gameOver) {
                update();
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // Initialize audio and canvas on window load
        window.onload = function () {
            initAudio(); // Initialize Tone.js players and music
            resizeCanvas(); // Set initial canvas size and rocket position
            initGame(); // Set up initial game state and show start message
        };
    </script>
</body>
</html>
